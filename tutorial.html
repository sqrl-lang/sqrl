<!--
Copyright 2019 Twitter, Inc.
Licensed under the Apache License, Version 2.0
http://www.apache.org/licenses/LICENSE-2.0
 --!>
<!DOCTYPE html>
<html lang="en">
  <head><meta name="generator" content="Hexo 3.8.0">
    <meta charset="utf-8">

    <title>SQRL | Tutorial </title>
    <meta name="description" content>
    <meta name="viewport" content="width=device-width, initial-scale=1">

    

    <!-- fonts -->
    <link href="//fonts.googleapis.com/css?family=Source+Sans+Pro:400,700" rel="stylesheet">
    <link href="//fonts.googleapis.com/css?family=Ubuntu:300,400,500,600,700" rel="stylesheet">

    <!-- stylesheets -->
    <link rel="stylesheet" href="/sqrl/style/doc.css">

    <!-- favicon -->
    <link rel="icon" href="/sqrl/images/favicon.ico">

    

  </head>
  <body>

   <script>window.__INITIAL_STATE__ = {"page":{"title":"Tutorial","path":"tutorial.html"},"data":{"navigation":{"logo":{"text":"SQRL Documentation","type":"link","path":"index.html"},"main":[{"text":"Introduction","type":"link","path":"index.html"},{"text":"Motivation","type":"link","path":"motivation.html"},{"text":"Tutorial","type":"link","path":"tutorial.html"},{"text":"Why is it unique?","type":"link","path":"unique.html"},{"text":"FAQ","type":"link","path":"faq.html"},{"text":"Examples","type":"label","children":[{"text":"Redis Database","type":"link","path":"examples/redis.html"},{"text":"REPL","type":"link","path":"examples/repl.html"},{"text":"Wikipedia","type":"link","path":"examples/wikipedia.html"}]},{"text":"Concepts","type":"label","children":[{"text":"Entities","type":"link","path":"language/entities.html"},{"text":"Labels","type":"link","path":"language/labels.html"},{"text":"Simple Counters","type":"link","path":"counters/simple.html"},{"text":"Unique Counters","type":"link","path":"counters/unique.html"},{"text":"Rate limiters","type":"link","path":"counters/ratelimit.html"},{"text":"Sessionization","type":"link","path":"counters/session.html"},{"text":"Text Pattern Matching","type":"link","path":"language/textpattern.html"},{"text":"Where Clauses","type":"link","path":"language/where.html"}]},{"text":"Standard Library","type":"label","children":[{"text":"Assert Functions","type":"link","path":"stdlib/assert.html"},{"text":"Bool Functions","type":"link","path":"stdlib/bool.html"},{"text":"Control Functions","type":"link","path":"stdlib/control.html"},{"text":"Data Functions","type":"link","path":"stdlib/data.html"},{"text":"Date-time Functions","type":"link","path":"stdlib/date-time.html"},{"text":"Entity Functions","type":"link","path":"stdlib/entity.html"},{"text":"List Functions","type":"link","path":"stdlib/list.html"},{"text":"Math Functions","type":"link","path":"stdlib/math.html"},{"text":"String Functions","type":"link","path":"stdlib/string.html"},{"text":"Type Functions","type":"link","path":"stdlib/type.html"}]},{"text":"Function Packages","type":"label","children":[{"text":"sqrl-cli-functions","type":"link","path":"packages/sqrl-cli-functions.html"},{"text":"sqrl-load-functions","type":"link","path":"packages/sqrl-load-functions.html"},{"text":"sqrl-redis-functions","type":"link","path":"packages/sqrl-redis-functions.html"},{"text":"sqrl-text-functions","type":"link","path":"packages/sqrl-text-functions.html"}]},{"text":"Defining Functions","type":"label","children":[{"text":"Simple Functions","type":"link","path":"functions/simple.html"},{"text":"Statements","type":"link","path":"functions/statement.html"},{"text":"When Clauses","type":"link","path":"functions/when.html"},{"text":"Custom Functions","type":"link","path":"functions/custom.html"}]},{"text":"Production Deployments","type":"label","children":[{"text":"Http Server","type":"link","path":"deployment/server.html"},{"text":"Async Queues","type":"link","path":"deployment/async.html"}]},{"text":"External Resources","type":"label"},{"text":"API Reference","type":"link","path":"reference/globals.html"},{"text":"Discord Chat","type":"link","path":"https://discord.gg/mMJwWT6"},{"text":"View on GitHub","type":"link","path":"https://github.com/twitter/sqrl"}]}},"config":{"timezone":"UTC","root":"/sqrl/","time_format":"HH:mm:ss","theme":"sqrl-hexo-theme-doc","theme_config":{"swagger_ui":{"version":2,"permalinks":true,"api_explorer":true,"download":"Download specification","show_extensions":false,"deep_linking":true,"display_operation_id":false,"doc_expansion":"none"},"search":{"skip":false,"background":false,"route":"/lunr.json"},"favicon":"images/favicon.ico"}}}</script>

    <div id="react-navigation-root"><div class="doc-navigation" data-reactroot><nav class="doc-navbar"><a href="/sqrl/index.html" class="doc-navbar__logo"><img src="/sqrl/images/logo.png" class="doc-navbar__logo__img"><span class="doc-navbar__logo__text">SQRL Documentation</span></a><i class="dc-icon dc-icon--close dc-icon--interactive doc-sidebar-close doc-navbar__sidebar-close doc-navbar__sidebar-close--desktop"></i><i class="dc-icon dc-icon--menu dc-icon--interactive doc-sidebar-toggle doc-navbar__sidebar-toggle"></i></nav><nav class="doc-sidebar"><div class="doc-sidebar__vertical-menu"><i class="dc-icon dc-icon--menu dc-icon--interactive doc-sidebar-toggle doc-sidebar-toggle--primary doc-sidebar__vertical-menu__item"></i><i class="dc-icon dc-icon--search dc-icon--interactive doc-sidebar__vertical-menu__item doc-sidebar__vertical-menu__item--primary"></i></div><div class="doc-sidebar-content"><div class="doc-sidebar__search-form"></div><ul class="doc-sidebar-list"></ul></div></nav></div></div>
    <div class="doc-content">
  <div class="dc-page">
    <div class="dc-card">
      <div id="react-search-results-root"></div>
      <div id="page-content" class="doc-formatting">
        <h1 id="Tutorial"><a href="#Tutorial" class="headerlink" title="Tutorial"></a>Tutorial</h1><p>Welcome to the SQRL tutorial! Before we begin, let&#x2019;s go over a few concepts.</p>
<p>SQRL takes an event, called an <strong>action</strong>, and turns it into one or more <strong>features</strong> (some special features are also called <strong>rules</strong>, but we&#x2019;ll get to that later). Your server-side application will usually send an action to a SQRL service, and do something based on the results of the features (i.e. show the user a warning or queue something for manual review).</p>
<p>An <strong>action</strong> is something the user did, or is about to do. For example, some common events include <code>login</code>, <code>signup</code>, <code>post_comment</code>, and <code>add_payment_method</code>. Actions are just JSON blobs that we call <code>ActionData</code>. For example, one of the most important actions at Twitter is <code>tweet</code>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">{&quot;name&quot;: &quot;tweet&quot;, &quot;username&quot;: &quot;floydophone&quot;, &quot;text&quot;: &quot;hello world!&quot;}</span><br></pre></td></tr></table></figure>
<p>Save that JSON blob into a file called <code>tweet.json</code>. We&#x2019;ll need it later.</p>
<h2 id="Wiring-up-features"><a href="#Wiring-up-features" class="headerlink" title="Wiring up features"></a>Wiring up features</h2><p>Now let&#x2019;s wire up some basic <strong>features</strong> in SQRL. <strong>Features</strong> are similar to variables in other languages. You can bind them using the <code>LET</code> keyword, and can reference them in any expression. Open up your favorite editor (hint: it&#x2019;s emacs) and create a file called <code>main.sqrl</code> with the following code in it:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">LET ActionData := input();</span><br><span class="line">LET ActionName := jsonValue(ActionData, &quot;$.name&quot;);</span><br><span class="line">LET Username := jsonValue(ActionData, &quot;$.username&quot;);</span><br><span class="line">LET Text := jsonValue(ActionData, &quot;$.text&quot;);</span><br></pre></td></tr></table></figure>
<p><code>jsonValue()</code> is a builtin function that parses a JSON string and returns the value at the given <a href="http://jsonpath.com/" target="_blank" rel="noopener">JSONPath</a>. Note that SQRL is smart enough to only parse the JSON once.</p>
<p>Let&#x2019;s fire up the <a href="https://en.wikipedia.org/wiki/Read%E2%80%93eval%E2%80%93print_loop" target="_blank" rel="noopener">repl</a> and play with it.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ npm install -g sqrl</span><br><span class="line">$ sqrl repl main.sqrl -s ActionData=@tweet.json</span><br><span class="line">sqrl&gt; Username</span><br><span class="line">&apos;floydophone&apos;</span><br><span class="line">sqrl&gt; Text</span><br><span class="line">&apos;hello world!&apos;</span><br><span class="line">sqrl&gt; ActionName</span><br><span class="line">&apos;tweet&apos;</span><br><span class="line">sqrl&gt; ActionData</span><br><span class="line">{ name: &apos;tweet&apos;, text: &apos;hello world!&apos;, username: &apos;floydophone&apos; }</span><br><span class="line">sqrl&gt; SqrlClock</span><br><span class="line">&apos;2019-02-21T09:15:45.615Z&apos;</span><br><span class="line">sqrl&gt; SomethingElse</span><br><span class="line">Error: Could not find the requested name:: SomethingElse</span><br></pre></td></tr></table></figure></p>
<p>Cool! You&#x2019;ll see that the features were extracted successfully, and that there&#x2019;s a built-in (but overridable) <code>SqrlClock</code> feature that represents the event time. Note also that features are case sensitive.</p>
<p>The current SQRL implementation runs on Node.js and is a compiler, not an interpreter. As we&#x2019;ve run this at scale for a long time at a startup that needed to conserve cash, we&#x2019;ve put in some effort to make this JS as efficient as we could. You can see a readable version of the compiled code for a feature by calling <code>printSource()</code>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sqrl&gt; printSource(Username);</span><br><span class="line">function() {</span><br><span class="line">  const f0 = () =&gt;</span><br><span class="line">    bluebird.resolve(</span><br><span class="line">      functions.attr(this.slots[&quot;ActionData&quot;].value(), &quot;username&quot;)</span><br><span class="line">    );</span><br><span class="line">  return this.load(&quot;ActionData&quot;).then(f0);</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>We can also spin up a SQRL service to serve this code over the network:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ sqrl serve main.sqrl &amp;</span><br><span class="line">$ curl -H &quot;Accept: application/json&quot; &apos;http://localhost:2288/run?features=Username,Text,ActionName&amp;pretty&apos; -d @tweet.json</span><br><span class="line">{</span><br><span class="line">  &quot;Username&quot;: &quot;floydophone&quot;,</span><br><span class="line">  &quot;Text&quot;: &quot;hello, world!&quot;,</span><br><span class="line">  &quot;ActionName&quot;: &quot;tweet&quot;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>We call this process of unpacking a JSON object into feature names <strong>wiring up the action</strong>. You usually do this work once per action type. Once an action is wired up, all of your existing features and rules will automatically start to work on the new action.</p>
<p>Let&#x2019;s say that we want to identify cryptocurrency spam on Twitter. A useful thing to know would be if the user is tweeting about specific cryptocurrencies, like Bitcoin (BTC) or Ethereum (ETH). Let&#x2019;s create a feature for that in the REPL:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sqrl&gt; LET HasCryptoKeywords := Text CONTAINS &quot;BTC&quot; OR Text CONTAINS &quot;ETH&quot;;</span><br><span class="line">false</span><br><span class="line">sqrl&gt; Text CONTAINS &quot;world&quot;</span><br><span class="line">true</span><br></pre></td></tr></table></figure>
<h2 id="Counters"><a href="#Counters" class="headerlink" title="Counters"></a>Counters</h2><p>Now let&#x2019;s say we want to count how often someone is tweeting about cryptocurrency. We&#x2019;ll need to use a <strong>stateful feature</strong> like a counter. Let&#x2019;s create a new feature <code>NumCryptoTweetsLastDay</code>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sqrl&gt; LET NumTweetsAboutCrypto := count(BY Username WHERE HasCryptoKeywords LAST DAY);</span><br><span class="line">0</span><br></pre></td></tr></table></figure>
<p>The value is <code>0</code> because there are no crypto keywords in our <code>tweet.json</code> file. Let&#x2019;s pretend that there are and see what happens:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sqrl&gt; LET HasCryptoKeywords := true;</span><br><span class="line">true</span><br><span class="line">sqrl&gt; NumTweetsAboutCrypto</span><br><span class="line">1</span><br><span class="line">sqrl&gt; NumTweetsAboutCrypto</span><br><span class="line">1</span><br></pre></td></tr></table></figure>
<p>Now the value is <code>1</code> because the tweet <code>HasCryptoKeywords</code>. But note that even though we evaluate the feature multiple times, the count doesn&#x2019;t go up. That&#x2019;s because SQRL is <strong>idempotent</strong>. This is a valuable property because it allows us to reprocess actions at a later time if we need to.</p>
<p>The SQRL repl has an <code>EXECUTE</code> command that will actually update the state and begin the processing of a new action:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">sqrl&gt; EXECUTE;</span><br><span class="line">sqrl&gt; NumTweetsAboutCrypto</span><br><span class="line">2</span><br><span class="line">sqrl&gt; NumTweetsAboutCrypto</span><br><span class="line">2</span><br><span class="line">sqrl&gt; EXECUTE;</span><br><span class="line">sqrl&gt; NumTweetsAboutCrypto</span><br><span class="line">3</span><br><span class="line">sqrl&gt; EXECUTE;</span><br></pre></td></tr></table></figure>
<p>At this point, we can flip <code>HasCryptoKeywords</code> back to false, and the counter will cease to increment.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">sqrl&gt; LET HasCryptoKeywords := false;</span><br><span class="line">false</span><br><span class="line">sqrl&gt; NumTweetsAboutCrypto</span><br><span class="line">3</span><br><span class="line">sqrl&gt; EXECUTE;</span><br><span class="line">sqrl&gt; NumTweetsAboutCrypto</span><br><span class="line">3</span><br></pre></td></tr></table></figure>
<p>This is what we mean when we say SQRL is a <strong>stateful</strong> rules language, and it&#x2019;s what sets it apart from many other rules languages.</p>
<p>Another thing to note is that the rule writer declaratively specified what they wanted to count. They didn&#x2019;t explicitly increment or decrement the counter. It&#x2019;s impossible for the counter to accidentally get out of sync, and the backend can be swapped out for a different data store without changing the SQRL source code. At Smyte, we did this at least four times: we moved from a quick and dirty Redis-based counters implementation, to RocksDB, and finally to Google Cloud BigTable. We also had a separate in-memory implementation for unit tests.</p>
<p>If you wait 15 minutes, this counter will eventually decrement. But why wait? All you need to do is change <code>SqrlClock</code> to be 15 minutes or more into the future and the counter will drop:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sqrl&gt; LET SqrlClock := &quot;2100-02-13T08:00:00.000Z&quot;</span><br><span class="line">&apos;2100-02-13T08:00:00.000Z&apos;</span><br><span class="line">sqrl&gt; NumTweetsAboutCrypto</span><br><span class="line">0</span><br></pre></td></tr></table></figure>
<p>This is super useful for replaying old actions or writing unit tests.</p>
<h2 id="Text-pattern-matching"><a href="#Text-pattern-matching" class="headerlink" title="Text pattern matching"></a>Text pattern matching</h2><p>As we all know, cryptocurrencies come and go&#x2026; often. We may want to keep a list of known crypto keywords that people can update rather than requiring a code change all the time.</p>
<p>First, make a file <code>CryptoKeywords.txt</code> containing:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">btc</span><br><span class="line">eth</span><br></pre></td></tr></table></figure></p>
<p>And then in the repl:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sqrl&gt; LET HasCryptoKeywords := patternMatches(&quot;CryptoKeywords.txt&quot;, Text);</span><br><span class="line">false</span><br><span class="line">sqrl&gt; patternMatches(&quot;CryptoKeywords.txt&quot;, &quot;buy some eth!&quot;)</span><br><span class="line">true</span><br><span class="line">sqrl&gt; patternMatches(&quot;CryptoKeywords.txt&quot;, &quot;buy some ETH!&quot;)</span><br><span class="line">true</span><br><span class="line">sqrl&gt; patternMatches(&quot;CryptoKeywords.txt&quot;, &quot;hi, seth!&quot;)</span><br><span class="line">false</span><br></pre></td></tr></table></figure>
<p>Note that <code>patternMatch()</code> understands word boundaries in multiple languages, so that &#x201C;hi, seth!&#x201D; won&#x2019;t trigger a false positive.</p>
<h2 id="Writing-a-rule"><a href="#Writing-a-rule" class="headerlink" title="Writing a rule"></a>Writing a rule</h2><p>Now let&#x2019;s say we want to limit people to 100 crypto tweets a day. We&#x2019;d never write a rule like this in the real world, but it&#x2019;s a useful example of what&#x2019;s possible. Rules are just boolean features with some extra metadata and a nice syntax. Here&#x2019;s how you&#x2019;d do it.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">sqrl&gt; CREATE RULE TooMuchCrypto WHERE NumTweetsAboutCrypto &gt; 10 WITH REASON &quot;User ${Username} tweeted about crypto ${NumTweetsAboutCrypto} in the last day&quot;;</span><br><span class="line">sqrl&gt; TooMuchCrypto</span><br><span class="line">false</span><br><span class="line">sqrl&gt; LET NumTweetsAboutCrypto := 11;</span><br><span class="line">11</span><br><span class="line">sqrl&gt; NumTweetsAboutCrypto</span><br><span class="line">true</span><br></pre></td></tr></table></figure>
<h2 id="Side-effects"><a href="#Side-effects" class="headerlink" title="Side effects"></a>Side effects</h2><p>Your rule should actually do something. Perhaps we want to label every user that is tweeting too much about crypto for manual review. You can do this with a <code>WHEN</code> block. A <code>WHEN</code> block ORs together a set of rules, and runs a side effect when one or more of those rules fire.</p>
<p>For example, if you had an <code>addUserToReviewQueue()</code> function defined, you could call it like this:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WHEN TooMuchCrypto THEN addUserToReviewQueue(&quot;cryptospam&quot;);</span><br></pre></td></tr></table></figure>
<p>The fuction <code>addUserToReviewQueue()</code> is not included with the default SQRL distribution, but if you have a review queue set up with an API, you can easily define a new <a href="functions/when.html">when clause function</a>.</p>
<h2 id="Next-steps"><a href="#Next-steps" class="headerlink" title="Next steps"></a>Next steps</h2><ul>
<li>View functions in the <a href="stdlib/assert.html">standard library</a></li>
<li>See the example using <a href="examples/redis.html">redis to store state</a></li>
<li>Try out a real life use case on <a href="examples/wikipedia.html">Wikipedia edits</a></li>
</ul>

        <div id="react-support-footer-root"></div>
      </div>
    </div>
  </div>
</div>

    


    

    <!-- js vendors -->
    <script src="//code.jquery.com/jquery-3.2.1.min.js" crossorigin="anonymous"></script>
    <script src="//cdnjs.cloudflare.com/ajax/libs/lunr.js/2.1.0/lunr.min.js"></script>

    <!-- js source  -->
    <script src="/sqrl/script/doc.js"></script>

    

  </body>
</html>

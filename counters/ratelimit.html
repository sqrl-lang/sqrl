<!DOCTYPE html>
<html lang="en">
  <head><meta name="generator" content="Hexo 3.8.0">
    <meta charset="utf-8">

    <title>SQRL | Rate limiters </title>
    <meta name="description" content>
    <meta name="viewport" content="width=device-width, initial-scale=1">

    

    <!-- fonts -->
    <link href="//fonts.googleapis.com/css?family=Source+Sans+Pro:400,700" rel="stylesheet">
    <link href="//fonts.googleapis.com/css?family=Ubuntu:300,400,500,600,700" rel="stylesheet">

    <!-- stylesheets -->
    <link rel="stylesheet" href="/sqrl/style/doc.css">

    <!-- favicon -->
    <link rel="icon" href="/sqrl/images/favicon.ico">

    

  </head>
  <body>

   <script>window.__INITIAL_STATE__ = {"page":{"title":"Rate limiters","path":"counters/ratelimit.html"},"data":{"navigation":{"logo":{"text":"SQRL Documentation","type":"link","path":"index.html"},"main":[{"text":"Documentation","type":"link","path":"index.html"},{"text":"Examples","type":"label","children":[{"text":"Redis Database","type":"link","path":"examples/redis.html"},{"text":"REPL","type":"link","path":"examples/repl.html"},{"text":"Wikipedia","type":"link","path":"examples/wikipedia.html"}]},{"text":"Concepts","type":"label","children":[{"text":"Nodes","type":"link","path":"language/nodes.html"},{"text":"Labels","type":"link","path":"language/labels.html"},{"text":"Simple Counters","type":"link","path":"counters/simple.html"},{"text":"Unique Counters","type":"link","path":"counters/unique.html"},{"text":"Rate limiters","type":"link","path":"counters/ratelimit.html"},{"text":"Sessionization","type":"link","path":"counters/session.html"},{"text":"Text Pattern Matching","type":"link","path":"language/textpattern.html"},{"text":"Where Clauses","type":"link","path":"language/where.html"}]},{"text":"Standard Library","type":"label","children":[{"text":"Array Functions","type":"link","path":"stdlib/array.html"},{"text":"Assert Functions","type":"link","path":"stdlib/assert.html"},{"text":"Block Functions","type":"link","path":"stdlib/block.html"},{"text":"Bool Functions","type":"link","path":"stdlib/bool.html"},{"text":"Compare Functions","type":"link","path":"stdlib/compare.html"},{"text":"Data Functions","type":"link","path":"stdlib/data.html"},{"text":"Date Functions","type":"link","path":"stdlib/date.html"},{"text":"Language Functions","type":"link","path":"stdlib/language.html"},{"text":"Load Functions","type":"link","path":"stdlib/load.html"},{"text":"Log Functions","type":"link","path":"stdlib/log.html"},{"text":"Math Functions","type":"link","path":"stdlib/math.html"},{"text":"Node Functions","type":"link","path":"stdlib/node.html"},{"text":"Source Functions","type":"link","path":"stdlib/source.html"},{"text":"String Functions","type":"link","path":"stdlib/string.html"},{"text":"Time Functions","type":"link","path":"stdlib/time.html"},{"text":"Type Functions","type":"link","path":"stdlib/type.html"}]},{"text":"Defining Functions","type":"label","children":[{"text":"Simple Functions","type":"link","path":"functions/simple.html"},{"text":"Statements","type":"link","path":"functions/statement.html"},{"text":"When Clauses","type":"link","path":"functions/when.html"},{"text":"Custom Functions","type":"link","path":"functions/custom.html"}]},{"text":"Production Deployments","type":"label","children":[{"text":"Http Server","type":"link","path":"deployment/server.html"},{"text":"Async Queues","type":"link","path":"deployment/async.html"}]},{"text":"External Resources","type":"label"},{"text":"View on GitHub","type":"link","path":"https://github.com/twitter/sqrl"}]}},"config":{"timezone":"UTC","root":"/sqrl/","time_format":"HH:mm:ss","theme":"sqrl-hexo-theme-doc","theme_config":{"swagger_ui":{"version":2,"permalinks":true,"api_explorer":true,"download":"Download specification","show_extensions":false,"deep_linking":true,"display_operation_id":false,"doc_expansion":"none"},"search":{"skip":false,"background":false,"route":"/lunr.json"},"favicon":"images/favicon.ico"}}}</script>

    <div id="react-navigation-root"><div class="doc-navigation" data-reactroot><nav class="doc-navbar"><a href="/sqrl/index.html" class="doc-navbar__logo"><img src="/sqrl/images/logo.png" class="doc-navbar__logo__img"><span class="doc-navbar__logo__text">SQRL Documentation</span></a><i class="dc-icon dc-icon--close dc-icon--interactive doc-sidebar-close doc-navbar__sidebar-close doc-navbar__sidebar-close--desktop"></i><i class="dc-icon dc-icon--menu dc-icon--interactive doc-sidebar-toggle doc-navbar__sidebar-toggle"></i></nav><nav class="doc-sidebar"><div class="doc-sidebar__vertical-menu"><i class="dc-icon dc-icon--menu dc-icon--interactive doc-sidebar-toggle doc-sidebar-toggle--primary doc-sidebar__vertical-menu__item"></i><i class="dc-icon dc-icon--search dc-icon--interactive doc-sidebar__vertical-menu__item doc-sidebar__vertical-menu__item--primary"></i></div><div class="doc-sidebar-content"><div class="doc-sidebar__search-form"></div><ul class="doc-sidebar-list"></ul></div></nav></div></div>
    <div class="doc-content">
  <div class="dc-page">
    <div class="dc-card">
      <div id="react-search-results-root"></div>
      <div id="page-content" class="doc-formatting">
        <h1 id="Rate-limiters"><a href="#Rate-limiters" class="headerlink" title="Rate limiters"></a>Rate limiters</h1><p>One of the most powerful ways to stop abuse is to create rate limiters. Rate limiters limit the number of times an action can be performed over a certain time period. By combining multiple features together, rate limiters become quite powerful.</p>
<h3 id="Your-first-rate-limiter"><a href="#Your-first-rate-limiter" class="headerlink" title="Your first rate limiter"></a>Your first rate limiter</h3><p>A good first rate limiter is limiting the number of signups that can come from an individual IP address. You can begin by editing rules/actions/signup.sqrl (or the equivalent rules file for your signup action) and adding a rate limiter:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CREATE RULE QuickSignupsByIp</span><br><span class="line">  WHERE rateLimited(BY Ip MAX 3 EVERY 10 MINUTES);</span><br></pre></td></tr></table></figure>
<p>The rateLimited function checks if the ratelimit has been hit. It has quite a few different options available. The ones in use here are:</p>
<p><strong>BY</strong> - The features to ratelimit by. Specifying multiple features (Ip, Machine) will group by each specific pair.<br><strong>MAX</strong> - The maximum number of actions allowed during the time period. In this case the first three events will not be ratelimited, but the fourth and onwards will.<br><strong>EVERY</strong> - How often the ratelimit will be reset. Valid timespan units are MONTHS, WEEKS, DAYS, HOURS, MINUTES, SECONDS.</p>
<p>In this example, we&#x2019;re rate limiting by Ip address, and allow a maximum of three signups every ten minutes. If a given IP is used in an action four or more times in a 10 minutes window, then we mark the address that is used with a &#x201C;possible_bot&#x201D; label.</p>
<h2 id="Feature-combinations"><a href="#Feature-combinations" class="headerlink" title="Feature combinations"></a>Feature combinations</h2><p>Our previous rate limiter does a decent job of slowing down bots, but it&#x2019;s prone to false positives if an IP is shared amongst lots of users (like a university wifi access point). To reduce the false positive rate, we can increase the <code>maxAmount</code> for our existing <code>NumSignups_TenMinutes_Ip</code> rate limiter, and create a more strict rate limiter on a combination of features.</p>
<p>For example, let&#x2019;s make a new rate limiter that limits how often the actions may be taken on the pair (Ip, UserAgent). To implement this, every unique user agent appearing on a given IP gets its own quota. With our previous rate limiter, all user agents appearing on a given IP share a single quota.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CREATE RULE QuickSignupsByUserAgentOnIp</span><br><span class="line">  WHERE rateLimited(BY Ip, UserAgent MAX 3 EVERY 10 MINUTES);</span><br><span class="line">WHEN QuickSignupsByUserAgentOnIp THEN addLabel(Ip, &quot;possible_bot&quot;);</span><br></pre></td></tr></table></figure>
<h2 id="Conditionals"><a href="#Conditionals" class="headerlink" title="Conditionals"></a>Conditionals</h2><p>Often you only want to rate limit under certain conditions. We provide a WHERE statement inside the rateLimited clause that will allow you to check if the user was rate limited but only in the specified condition.</p>
<p>An easy example of where that is useful is high value payments. The rule described below will allow any number of payments under $100, but only a maximum of two payment over that per day.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">LET IsHighDollarPaymentAmount := PaymentAmountUsd &gt;= 100;</span><br><span class="line">CREATE RULE MultipleHighValuePurchasesByActorDay WHERE</span><br><span class="line">  rateLimited(BY Actor MAX 2 EVERY DAY WHERE IsHighDollarPaymentAmount);</span><br></pre></td></tr></table></figure>
<h3 id="A-strikes-system-example"><a href="#A-strikes-system-example" class="headerlink" title="A strikes system example"></a>A strikes system example</h3><p>You can use rate limiters to build advanced policies, such as a strikes system for rules.</p>
<p>If you already have a rule in place and you want to give the user (or IP, or any combination of features) &#x201C;3 strikes&#x201D;, simply do the following:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CREATE RULE ThreeStrikesCheating</span><br><span class="line">  WHERE rateLimited(BY Actor MAX 2 EVERY WEEK WHERE Cheated);</span><br></pre></td></tr></table></figure>
<p>We leave it up to the user to define the Cheated feature. To get started on that though you&#x2019;ll want to review our features documentation.</p>
<h3 id="Conditional-rate-limiters-behavior"><a href="#Conditional-rate-limiters-behavior" class="headerlink" title="Conditional rate limiters behavior"></a>Conditional rate limiters behavior</h3><p>Sometimes you may only want a rate limiter to run if a given condition is met. For example, perhaps we want to limit the number of high-value purchases a user can make.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">LET IsHighDollarPaymentAmount := PaymentAmountUsd &gt;= 100;</span><br><span class="line">CREATE RULE MultipleHighValuePurchasesByActorDay</span><br><span class="line">  WHERE rateLimited(BY Actor MAX 2 EVERY DAY WHERE IsHighDollarPaymentAmount);</span><br></pre></td></tr></table></figure>
<p>The statement above will allow each Actor to make a maximum of 2 payments for $100 or above each DAY. Once a specific Actor has made the two payments in one day the rate limit will be triggered and any future payments (even if they are less than $100) will be flagged.</p>
<h3 id="Conditions-inside-and-outside-of-the-rateLimited-clause"><a href="#Conditions-inside-and-outside-of-the-rateLimited-clause" class="headerlink" title="Conditions inside and outside of the rateLimited clause"></a>Conditions inside and outside of the rateLimited clause</h3><p>The position of the IsHighDollarPaymentAmount inside or outside of the rateLimited() function changes the behavior.</p>
<p>As an example, within one twenty-four hour period a user made the following payments in order: $110, $30, $10, $120, $200, $50.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rateLimited(BY Actor MAX 2 EVERY DAY) AND IsHighDollarPaymentAmount</span><br></pre></td></tr></table></figure>
<p>This would fire on all payments over $100, after the user had made two previous purchases that day. In the example given, it would fire on the $120, and $200 payments.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rateLimited(BY Actor MAX 2 EVERY DAY WHERE IsHighDollarPaymentAmount)</span><br></pre></td></tr></table></figure>
<p>This would fire on all payments, after the user had made two previous purchases for over $100. In the given example, it would fire on the $200 and $50 payments.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rateLimited(BY Actor MAX 2 EVERY DAY WHERE IsHighDollarPaymentAmount) AND IsHighDollarPaymentAmount</span><br></pre></td></tr></table></figure>
<p>This would fire on all payments over $100, after the user had made two previous purchases for over $100. In the given example it would only fire on the $200 purchase.</p>
<h2 id="Leaky-buckets"><a href="#Leaky-buckets" class="headerlink" title="Leaky buckets"></a>Leaky buckets</h2><p>Up until this point, we&#x2019;ve created rate limiters that refill their entire quota at the end of each period. It&#x2019;s often more effective to utilize &#x201C;leaky bucket&#x201D; quota refills, where the quota slowly builds up over an extended period rather than all at once. This severely punishes attackers who continue to go over their quota, while minimizing the impact on legitimate behavior.</p>
<p>Let&#x2019;s add a leaky bucket rate limiter on the Simhash of every comment posted. A Simhash is a fuzzy text fingerprint of the comments text. By ratelimiting on that we ensure that the same (or very similar) text may only be sent a limited number of times by any actor throughout the system. This is a powerful way to automatically stop large-scale spam attacks without writing custom text content rules or rate limiting the actor, IP, or other connection characteristics.</p>
<p>The following rate limiter limits an individual fuzzy text fingerprint may only be used 100 times a minute, and if the quota is exceeded the rate limit goes down to 10 times a minute.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CREATE RULE NumCommentsSimhash WHERE rateLimited(BY Simhash MAX 100 REFILL 10 EVERY MINUTE);</span><br></pre></td></tr></table></figure>
<h2 id="Strict-mode"><a href="#Strict-mode" class="headerlink" title="Strict mode"></a>Strict mode</h2><p>Often when you create a ratelimit (such as the one above) you want to penalize the rate limited entity once their quota has been exhausted. To accomplish this, Smyte has created a special STRICT mode. Once an entity has been rate limited in STRICT mode they will be rate limited until the entire refill time period has passed.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CREATE RULE UserCommentBot WHERE rateLimited(BY Actor MAX 5 EVERY MINUTE STRICT);</span><br></pre></td></tr></table></figure>
        <div id="react-support-footer-root"></div>
      </div>
    </div>
  </div>
</div>

    


    

    <!-- js vendors -->
    <script src="//code.jquery.com/jquery-3.2.1.min.js" crossorigin="anonymous"></script>
    <script src="//cdnjs.cloudflare.com/ajax/libs/lunr.js/2.1.0/lunr.min.js"></script>

    <!-- js source  -->
    <script src="/sqrl/script/doc.js"></script>

    

  </body>
</html>

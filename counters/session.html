<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">

    <title>SQRL | Sessionization </title>
    <meta name="description" content="">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    

    <!-- fonts -->
    <link href="//fonts.googleapis.com/css?family=Source+Sans+Pro:400,700" rel="stylesheet">
    <link href="//fonts.googleapis.com/css?family=Ubuntu:300,400,500,600,700" rel="stylesheet">

    <!-- stylesheets -->
    <link rel="stylesheet" href="/sqrl/style/doc.css">

    <!-- favicon -->
    <link rel="icon" href="/sqrl/images/favicon.ico">

    

  <meta name="generator" content="Hexo 6.3.0"></head>
  <body>

   <script>window.__INITIAL_STATE__ = {"page":{"title":"Sessionization","path":"counters/session.html"},"data":{"navigation":{"logo":{"text":"SQRL Documentation","type":"link","path":"index.html"},"main":[{"text":"Introduction","type":"link","path":"index.html"},{"text":"Motivation","type":"link","path":"motivation.html"},{"text":"Tutorial","type":"link","path":"tutorial.html"},{"text":"Why is it unique?","type":"link","path":"unique.html"},{"text":"FAQ","type":"link","path":"faq.html"},{"text":"Examples","type":"label","children":[{"text":"Redis Database","type":"link","path":"examples/redis.html"},{"text":"REPL","type":"link","path":"examples/repl.html"},{"text":"Wikipedia","type":"link","path":"examples/wikipedia.html"}]},{"text":"Concepts","type":"label","children":[{"text":"Entities","type":"link","path":"language/entities.html"},{"text":"Labels","type":"link","path":"language/labels.html"},{"text":"Simple Counters","type":"link","path":"counters/simple.html"},{"text":"Unique Counters","type":"link","path":"counters/unique.html"},{"text":"Rate limiters","type":"link","path":"counters/ratelimit.html"},{"text":"Sessionization","type":"link","path":"counters/session.html"},{"text":"Text Pattern Matching","type":"link","path":"language/textpattern.html"},{"text":"Include and Where Clauses","type":"link","path":"language/where.html"},{"text":"Cost Optimisation","type":"link","path":"language/cost.html"}]},{"text":"Standard Library","type":"label","children":[{"text":"Assert Functions","type":"link","path":"stdlib/assert.html"},{"text":"Bool Functions","type":"link","path":"stdlib/bool.html"},{"text":"Control Functions","type":"link","path":"stdlib/control.html"},{"text":"Data Functions","type":"link","path":"stdlib/data.html"},{"text":"Date-time Functions","type":"link","path":"stdlib/date-time.html"},{"text":"Entity Functions","type":"link","path":"stdlib/entity.html"},{"text":"List Functions","type":"link","path":"stdlib/list.html"},{"text":"Math Functions","type":"link","path":"stdlib/math.html"},{"text":"String Functions","type":"link","path":"stdlib/string.html"},{"text":"Type Functions","type":"link","path":"stdlib/type.html"}]},{"text":"Function Packages","type":"label","children":[{"text":"sqrl-cli-functions","type":"link","path":"packages/sqrl-cli-functions.html"},{"text":"sqrl-load-functions","type":"link","path":"packages/sqrl-load-functions.html"},{"text":"sqrl-redis-functions","type":"link","path":"packages/sqrl-redis-functions.html"},{"text":"sqrl-text-functions","type":"link","path":"packages/sqrl-text-functions.html"}]},{"text":"Defining Functions","type":"label","children":[{"text":"Simple Functions","type":"link","path":"functions/simple.html"},{"text":"Statements","type":"link","path":"functions/statement.html"},{"text":"When Clauses","type":"link","path":"functions/when.html"},{"text":"Custom Functions","type":"link","path":"functions/custom.html"}]},{"text":"Production Deployments","type":"label","children":[{"text":"Sync and Async","type":"link","path":"deployment/async.html"},{"text":"Http Server","type":"link","path":"deployment/server.html"},{"text":"Queues","type":"link","path":"deployment/queue.html"}]},{"text":"External Resources","type":"label"},{"text":"API Reference","type":"link","path":"reference/globals.html"},{"text":"Discord Chat","type":"link","path":"https://discord.gg/mMJwWT6"},{"text":"View on GitHub","type":"link","path":"https://github.com/sqrl-lang/sqrl"}]}},"config":{"timezone":"UTC","root":"/sqrl/","time_format":"HH:mm:ss","theme":"sqrl-hexo-theme-doc","theme_config":{"swagger_ui":{"version":2,"permalinks":true,"api_explorer":true,"download":"Download specification","show_extensions":false,"deep_linking":true,"display_operation_id":false,"doc_expansion":"none"},"search":{"skip":false,"background":false,"route":"/lunr.json"},"favicon":"images/favicon.ico"}}}</script>

    <div id="react-navigation-root"><div class="doc-navigation" data-reactroot=""><nav class="doc-navbar"><a href="/sqrl/index.html" class="doc-navbar__logo"><img src="/sqrl/images/logo.png" class="doc-navbar__logo__img"/><span class="doc-navbar__logo__text">SQRL Documentation</span></a><i class="dc-icon dc-icon--close dc-icon--interactive doc-sidebar-close doc-navbar__sidebar-close doc-navbar__sidebar-close--desktop"></i><i class="dc-icon dc-icon--menu dc-icon--interactive doc-sidebar-toggle doc-navbar__sidebar-toggle"></i></nav><nav class="doc-sidebar"><div class="doc-sidebar__vertical-menu"><i class="dc-icon dc-icon--menu dc-icon--interactive doc-sidebar-toggle doc-sidebar-toggle--primary doc-sidebar__vertical-menu__item"></i><i class="dc-icon dc-icon--search dc-icon--interactive doc-sidebar__vertical-menu__item doc-sidebar__vertical-menu__item--primary"></i></div><div class="doc-sidebar-content"><div class="doc-sidebar__search-form"></div><ul class="doc-sidebar-list"></ul></div></nav></div></div>
    <div class="doc-content">
  <div class="dc-page">
    <div class="dc-card">
      <div id="react-search-results-root"></div>
      <div id="page-content" class="doc-formatting">
        <html><head></head><body><h1 id="Sessionization"><a href="#Sessionization" class="headerlink" title="Sessionization"></a>Sessionization</h1><p>Sessionization is a powerful tool for combating abuse and is often used to detect anomalies, identify bots, cluster accounts, and surface other risky behavior. In this post we will explore how sessionization works and some interesting properties associated with sessions.</p>
<h2 id="What-is-a-session"><a href="#What-is-a-session" class="headerlink" title="What is a session?"></a>What is a session?</h2><p>A session is “a unit of measurement of a user’s actions taken within a period of time or with regard to completion of a task.” In other words, sessions allow us to cluster activity from a particular time window together.</p>
<p>SQRL (the Smyte Query and Rules Language) allows you to easily create sessions using custom keys across arbitrary timespans in real-time as your data streams in. Smyte’s definition of a session is slightly broader in that we do not restrict sessions to just users. In fact, we can create sessions that are keyed off of IP addresses, credit cards, URLs, or any feature for that matter without having to wait for complex, expensive batch jobs to run.</p>
<h2 id="Getting-started"><a href="#Getting-started" class="headerlink" title="Getting started"></a>Getting started</h2><p>Let’s imagine a simple case where we wanted to create a one hour session for a user. We can accomplish this with a single line of code:</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LET UserHourSession := sessionize(BY User EVERY 1 HOUR);</span><br></pre></td></tr></tbody></table></figure>
<p>From now on, whenever the user performs an action (logs in, sends a message, makes a payment, etc) we will check to see if a session exists. If no session exists, we will create a session that lasts for one hour.</p>
<p><img src="/sqrl/../images/session/one_session.jpeg" alt="Creating a one hour session"></p>
<p>If the specified time elapses with no activity, the current session is destroyed. Any subsequent event will create a new session.</p>
<p><img src="/sqrl/../images/session/two_sessions.jpeg" alt="Creating a new session after too much time has elapsed"></p>
<p>If the session does exist, then we will extend the current session’s window by an additional hour.</p>
<p><img src="/sqrl/../images/session/extended_session.jpeg" alt="Extending a session"></p>
<p>It is important to note that each session gets its own unique ID. This identifier can be used in simple counters, unique counters, or rate-limits to identify suspect behavior and can even be used to determine the age of the session since we embed timestamps in all Smyte IDs.</p>
<h2 id="Conditional-sessions"><a href="#Conditional-sessions" class="headerlink" title="Conditional sessions"></a>Conditional sessions</h2><p>In our first example, we created a simple session with no conditions; however, we can easily add qualifiers with a WHERE clause.</p>
<p>Let’s imagine we want to create a session for any time a user sends a message.</p>
<p>We could accomplish this with the following line of code:</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LET UserMessageHourSession := sessionize( BY User EVERY 1 HOUR WHERE ActionName = "send_message" );</span><br></pre></td></tr></tbody></table></figure>

<p>In this case, we only consider message events as valid actions to be grouped in a session.</p>
<h2 id="Detecting-bots"><a href="#Detecting-bots" class="headerlink" title="Detecting bots"></a>Detecting bots</h2><p>As mentioned above, Smyte tracks session age through unique IDs. To show how this is useful in detecting bots, let’s consider the example above. If we call the dateDiff function, we can see how many hours have elapsed since the session was created.</p>
<h3 id="Session-age"><a href="#Session-age" class="headerlink" title="Session age"></a>Session age</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">LET UserMessageHourSession := sessionize(BY User EVERY 1 HOUR WHERE ActionName="send_message");</span><br><span class="line"></span><br><span class="line">-- Get session age in hours</span><br><span class="line">LET MessageHourSessionAgeInHours := dateDiff(</span><br><span class="line">  "HOUR", </span><br><span class="line">  UserMessageHourSession, </span><br><span class="line">  EventTimestamp</span><br><span class="line">);</span><br></pre></td></tr></tbody></table></figure>

<p>Remember that as soon as an hour has elapsed with no activity the session is destroyed and a new one will be created. This means that if a user has a message session that is 24 hours old they have been actively sending messages for the past 24 hours straight! This type of behavior often indicates that the user is in fact a bot.</p>
<p><img src="/sqrl/../images/session/bot_session.jpeg" alt="Bot session"></p>
<p>With this insight, you can easily create a rule to flag and review this suspicious behavior.</p>
<h3 id="Session-age-rule"><a href="#Session-age-rule" class="headerlink" title="Session age rule"></a>Session age rule</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CREATE RULE DayLongMessageSession WHERE MessageHourSessionAgeInHours &gt;= 24</span><br><span class="line"> WITH REASON "User has been sending a message for the "</span><br><span class="line">             "past ${MessageHourSessionAgeInHours} hours straight";</span><br></pre></td></tr></tbody></table></figure>
<!-- @todo: These features have not been implemented in open-source SQRL (yet!)

## Variance checks

Another interesting way of using sessions is to cluster accounts together and look for relations or anomalous behavior. Let’s imagine we are trying to detect suspect email signups from IP addresses.

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Email,       Ip,      Timestamp</span><br><span class="line">a@gmail.com, 1.2.3.4, 2018-04-11T04:35:30.143Z</span><br><span class="line">b@gmail.com, 1.2.3.4, 2018-04-11T04:36:30.143Z</span><br><span class="line">c@gmail.com, 1.2.3.4, 2018-04-11T04:37:30.143Z</span><br><span class="line">d@email.com, 1.2.3.4, 2018-04-11T04:38:30.143Z</span><br><span class="line">e@gmail.com, 1.2.3.4, 2018-04-11T04:39:30.143Z</span><br><span class="line">f@gmail.com, 1.2.3.4, 2018-04-11T04:40:30.143Z</span><br></pre></td></tr></table></figure>

<p>Notice that all the email addresses here are of a fixed length. This is a common pattern we see when looking for fake accounts. Attackers often use scripts that generate email addresses of a fixed length, albeit with random characters.</p>
<p>We can take advantage of sessions here to segment our data and look for an anomaly like this, since it is extremely atypical for all email addresses to be of the same length.</p>
<h3 id="Variance-in-a-session"><a href="#Variance-in-a-session" class="headerlink" title="Variance in a session"></a>Variance in a session</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LET IpSignupSessionHour := sessionize(BY Ip EVERY 1 HOUR WHERE IsSignupAction);</span><br><span class="line">LET EmailLengthIpSessionVariance := variance(ActorEmailHandleLength GROUP BY IpSignupSession);</span><br></pre></td></tr></table></figure>

<p>With two lines of code we can now look at the variance in email lengths across signups for a given IP address!<br>If we wanted to create a rule to flag this we might want to add a minimum number of signups before considering this risky behavior. All this would require is counting how many total signups we have seen for this signup session.<br>–&gt;</p>
<h2 id="Counting"><a href="#Counting" class="headerlink" title="Counting"></a>Counting</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">LET NumSignupsByIpSignupSessionHour := count(</span><br><span class="line">  BY IpSignupSessionHour LAST WEEK WHERE IsSignupAction</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>Here, we are counting how many signups we have seen for this session over the past week. This gives us plenty of buffer in case the IP has continuous signup activity (remember that as soon as an hour with no signups elapses we will get a new session ID).</p>
<!-- @todo: These features have not been implemented in open-source SQRL (yet!)
To tie it all together we can create a rule like this:

## Variance rule

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">LET IpSignupSessionHour := sessionize(BY Ip EVERY 1 HOUR WHERE IsSignupAction);</span><br><span class="line">LET EmailLengthIpSessionVariance := variance(</span><br><span class="line">	ActorEmailHandleLength GROUP BY IpSignupSession</span><br><span class="line">);</span><br><span class="line">LET NumSignupsByIpSignupSessionHour := count(</span><br><span class="line">  BY IpSignupSessionHour LAST WEEK WHERE IsSignupAction</span><br><span class="line">);</span><br><span class="line">CREATE RULE LowVarianceEmailSignup</span><br><span class="line">  WHERE EmailLengthIpSessionVariance &lt; 1</span><br><span class="line">  AND NumSignupsByIpSignupSessionHour &gt; 10</span><br><span class="line">  WITH REASON &quot;We have seen $&#123;NumSignupsByIpSignupSessionHour&#125; signups from &quot;</span><br><span class="line">              &quot;this IP with low variance in email length&quot;;</span><br><span class="line"></span><br><span class="line">LET IpSignupSessionHour := sessionize(BY Ip EVERY 1 HOUR WHERE IsSignupAction);</span><br><span class="line">LET EmailLengthIpSessionVariance := variance(ActorEmailHandleLength GROUP BY IpSignupSession);</span><br><span class="line">LET NumSignupsByIpSignupSessionHour := count(BY IpSignupSessionHour LAST WEEK WHERE IsSignupAction);</span><br><span class="line">CREATE RULE LowVarianceEmailSignup</span><br><span class="line">  WHERE EmailLengthIpSessionVariance &lt; 1 AND NumSignupsByIpSignupSessionHour &gt; 10</span><br><span class="line">  WITH REASON &quot;We have seen $&#123;NumSignupsByIpSignupSessionHour&#125; signups from this IP &quot;</span><br><span class="line">              &quot;with low variance in email length&quot;;</span><br></pre></td></tr></table></figure>

<h2 id="Velocity"><a href="#Velocity" class="headerlink" title="Velocity"></a>Velocity</h2><p>The final use case for sessions that we will discuss here revolve around velocities. Velocities allow us to flag the rate or speed of which something is being done. In this example, let’s imagine we are trying to flag users who are making payments too quickly.</p>
<p>This can be done with three lines of code using the velocity function.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">-- Create hour long session for payments</span><br><span class="line">LET PaymentSessionHour := sessionize(BY User EVERY 1 HOUR WHERE IsPaymentAction);</span><br><span class="line">-- Track how many payments are being made in the current session</span><br><span class="line">LET PaymentSessionSize := count(BY PaymentSessionHour LAST DAY);</span><br><span class="line">-- Calculate velocity / rate at which payments are being made. </span><br><span class="line">-- The third parameter is the minimum # of events required for us to calculate velocities.</span><br><span class="line">LET PaymentVelocity := velocity(</span><br><span class="line">  PaymentSessionHour, </span><br><span class="line">  PaymentSessionSize, </span><br><span class="line">  3</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>velocity takes in three arguments - the session, the total size, and the minimum number of events required for us to calculate velocity. Velocities calculated here are the per&#x2F;hour rate at which the action is occurring.</p>
<p>More often than not you will have some idea of what a risky velocity might be, but sometimes you might not know this offhand or you do not want to statically set this. We can take advantage of Smyte’s streaming statistics to set these thresholds dynamically.</p>
<p>To do this we would use the percentileCheck function. percentileCheck expects two arguments - the percentile to check against and a value.</p>
<h2 id="Percentile"><a href="#Percentile" class="headerlink" title="Percentile"></a>Percentile</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">LET PaymentVelocity := velocity(PaymentSession, PaymentSessionSize, 3);</span><br><span class="line">LET IsPaymentVelocity99Percentile := percentileCheck(99, PaymentVelocity);</span><br><span class="line">CREATE RULE 99PercentilePaymentVelocity</span><br><span class="line">  WHERE IsPaymentVelocity99Percentile</span><br><span class="line">  WITH REASON “User is in the 99th percentile for payment velocity: $&#123;PaymentVelocity&#125;”;</span><br></pre></td></tr></table></figure>
<p>–&gt;</p>
--></body></html>
        <div id="react-support-footer-root"></div>
      </div>
    </div>
  </div>
</div>

    


    

    <!-- js vendors -->
    <script src="//code.jquery.com/jquery-3.2.1.min.js" crossorigin="anonymous"></script>
    <script src="//cdnjs.cloudflare.com/ajax/libs/lunr.js/2.1.0/lunr.min.js"></script>

    <!-- js source  -->
    <script src="/sqrl/script/doc.js"></script>

    

  </body>
</html>

<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">

    <title>SQRL | What makes SQRL unique? </title>
    <meta name="description" content="">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    

    <!-- fonts -->
    <link href="//fonts.googleapis.com/css?family=Source+Sans+Pro:400,700" rel="stylesheet">
    <link href="//fonts.googleapis.com/css?family=Ubuntu:300,400,500,600,700" rel="stylesheet">

    <!-- stylesheets -->
    <link rel="stylesheet" href="/sqrl/style/doc.css">

    <!-- favicon -->
    <link rel="icon" href="/sqrl/images/favicon.ico">

    

  <meta name="generator" content="Hexo 6.0.0"></head>
  <body>

   <script>window.__INITIAL_STATE__ = {"page":{"title":"What makes SQRL unique?","path":"unique.html"},"data":{"navigation":{"logo":{"text":"SQRL Documentation","type":"link","path":"index.html"},"main":[{"text":"Introduction","type":"link","path":"index.html"},{"text":"Motivation","type":"link","path":"motivation.html"},{"text":"Tutorial","type":"link","path":"tutorial.html"},{"text":"Why is it unique?","type":"link","path":"unique.html"},{"text":"FAQ","type":"link","path":"faq.html"},{"text":"Examples","type":"label","children":[{"text":"Redis Database","type":"link","path":"examples/redis.html"},{"text":"REPL","type":"link","path":"examples/repl.html"},{"text":"Wikipedia","type":"link","path":"examples/wikipedia.html"}]},{"text":"Concepts","type":"label","children":[{"text":"Entities","type":"link","path":"language/entities.html"},{"text":"Labels","type":"link","path":"language/labels.html"},{"text":"Simple Counters","type":"link","path":"counters/simple.html"},{"text":"Unique Counters","type":"link","path":"counters/unique.html"},{"text":"Rate limiters","type":"link","path":"counters/ratelimit.html"},{"text":"Sessionization","type":"link","path":"counters/session.html"},{"text":"Text Pattern Matching","type":"link","path":"language/textpattern.html"},{"text":"Include and Where Clauses","type":"link","path":"language/where.html"},{"text":"Cost Optimisation","type":"link","path":"language/cost.html"}]},{"text":"Standard Library","type":"label","children":[{"text":"Assert Functions","type":"link","path":"stdlib/assert.html"},{"text":"Bool Functions","type":"link","path":"stdlib/bool.html"},{"text":"Control Functions","type":"link","path":"stdlib/control.html"},{"text":"Data Functions","type":"link","path":"stdlib/data.html"},{"text":"Date-time Functions","type":"link","path":"stdlib/date-time.html"},{"text":"Entity Functions","type":"link","path":"stdlib/entity.html"},{"text":"List Functions","type":"link","path":"stdlib/list.html"},{"text":"Math Functions","type":"link","path":"stdlib/math.html"},{"text":"String Functions","type":"link","path":"stdlib/string.html"},{"text":"Type Functions","type":"link","path":"stdlib/type.html"}]},{"text":"Function Packages","type":"label","children":[{"text":"sqrl-cli-functions","type":"link","path":"packages/sqrl-cli-functions.html"},{"text":"sqrl-load-functions","type":"link","path":"packages/sqrl-load-functions.html"},{"text":"sqrl-redis-functions","type":"link","path":"packages/sqrl-redis-functions.html"},{"text":"sqrl-text-functions","type":"link","path":"packages/sqrl-text-functions.html"}]},{"text":"Defining Functions","type":"label","children":[{"text":"Simple Functions","type":"link","path":"functions/simple.html"},{"text":"Statements","type":"link","path":"functions/statement.html"},{"text":"When Clauses","type":"link","path":"functions/when.html"},{"text":"Custom Functions","type":"link","path":"functions/custom.html"}]},{"text":"Production Deployments","type":"label","children":[{"text":"Sync and Async","type":"link","path":"deployment/async.html"},{"text":"Http Server","type":"link","path":"deployment/server.html"},{"text":"Queues","type":"link","path":"deployment/queue.html"}]},{"text":"External Resources","type":"label"},{"text":"API Reference","type":"link","path":"reference/globals.html"},{"text":"Discord Chat","type":"link","path":"https://discord.gg/mMJwWT6"},{"text":"View on GitHub","type":"link","path":"https://github.com/sqrl-lang/sqrl"}]}},"config":{"timezone":"UTC","root":"/sqrl/","time_format":"HH:mm:ss","theme":"sqrl-hexo-theme-doc","theme_config":{"swagger_ui":{"version":2,"permalinks":true,"api_explorer":true,"download":"Download specification","show_extensions":false,"deep_linking":true,"display_operation_id":false,"doc_expansion":"none"},"search":{"skip":false,"background":false,"route":"/lunr.json"},"favicon":"images/favicon.ico"}}}</script>

    <div id="react-navigation-root"><div class="doc-navigation" data-reactroot=""><nav class="doc-navbar"><a href="/sqrl/index.html" class="doc-navbar__logo"><img src="/sqrl/images/logo.png" class="doc-navbar__logo__img"/><span class="doc-navbar__logo__text">SQRL Documentation</span></a><i class="dc-icon dc-icon--close dc-icon--interactive doc-sidebar-close doc-navbar__sidebar-close doc-navbar__sidebar-close--desktop"></i><i class="dc-icon dc-icon--menu dc-icon--interactive doc-sidebar-toggle doc-navbar__sidebar-toggle"></i></nav><nav class="doc-sidebar"><div class="doc-sidebar__vertical-menu"><i class="dc-icon dc-icon--menu dc-icon--interactive doc-sidebar-toggle doc-sidebar-toggle--primary doc-sidebar__vertical-menu__item"></i><i class="dc-icon dc-icon--search dc-icon--interactive doc-sidebar__vertical-menu__item doc-sidebar__vertical-menu__item--primary"></i></div><div class="doc-sidebar-content"><div class="doc-sidebar__search-form"></div><ul class="doc-sidebar-list"></ul></div></nav></div></div>
    <div class="doc-content">
  <div class="dc-page">
    <div class="dc-card">
      <div id="react-search-results-root"></div>
      <div id="page-content" class="doc-formatting">
        <html><head></head><body><h1 id="What-makes-SQRL-unique"><a href="#What-makes-SQRL-unique" class="headerlink" title="What makes SQRL unique?"></a>What makes SQRL unique?</h1><p>SQRL has a number of features that we think are cool and/or unique.</p>
<h2 id="Parallel-data-fetching"><a href="#Parallel-data-fetching" class="headerlink" title="Parallel data fetching"></a>Parallel data fetching</h2><p>Data fetching is implicit and can be parallelized. The runtime can decide whether to fetch eagerly or lazily to balance speed vs cost as needed without changing the source of the rule.</p>
<p>This is similar to a number of projects, including <a target="_blank" rel="noopener" href="https://github.com/facebook/Haxl">Haxl</a>, but isn’t part of any mainstream languages to our knowledge.</p>
<h2 id="Fail-open-error-handling"><a href="#Fail-open-error-handling" class="headerlink" title="Fail-open error handling"></a>Fail-open error handling</h2><p>SQRL uses <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Three-valued_logic">three-valued logic</a> to handle errors (they are treated as unknown values). For example, if a downstream service goes down, SQRL will do the right thing — it will fail open <em>unless</em> the service would not have affected the result.</p>
<h2 id="Declarative-state"><a href="#Declarative-state" class="headerlink" title="Declarative state"></a>Declarative state</h2><p>SQRL functions like <code>count()</code> track their own state declaratively, rather than requiring the rule author to write rules to explicitly mutate state. A problem we found with other systems was that you’d have a set of rules that mutate state imperatively, and a set of rules that read from the state, often written by different people. Keeping these rules in sync is painful, and if they fall out of sync your state will be very inconsistent.</p>
<p>We think this is unique to SQRL (but it’s a pretty good idea so someone else must have done it somewhere).</p>
<h2 id="Not-Turing-complete"><a href="#Not-Turing-complete" class="headerlink" title="Not Turing-complete"></a>Not Turing-complete</h2><p>SQRL does not have user-defined functions, recursion or unbounded loops. This produces simpler code for non-programmers and allows deep static analysis. Logic that needs the power of a full programming language can be implemented as new library functions.</p>
<h2 id="Cost-optimisation"><a href="#Cost-optimisation" class="headerlink" title="Cost optimisation"></a>Cost optimisation</h2><p>SQRL will optimise your code to be cheaper to run in production. Expressions such as <code>a() OR b()</code> can be re-ordered by the cost of each function in production (if you have that data.) For more detail see the <a href="language/cost.html">page on cost optimisation</a>.</p>
<h2 id="Entities-as-first-class-citizens"><a href="#Entities-as-first-class-citizens" class="headerlink" title="Entities as first-class citizens"></a>Entities as first-class citizens</h2><p>SQRL has a notion of an “entity”, which is a <code>type</code> (i.e. “EmailAddress”) and a string <code>key</code> (i.e. “<a href="mailto:foo@bar.com">foo@bar.com</a>“). It gets a stable 64 bit ID called a <code>UniqueId</code> where the most significant bits of the ID are the timestamp that the ID was created. Subsequent references to the same (<code>type</code>, <code>key</code>) pair will get the same <code>UniqueId</code>.</p>
<p>This has many advantages:</p>
<ul>
<li>We often use entities as keys in databases, and a 64 bit <code>UniqueId</code> requires less storage than the full entity <code>key</code>.</li>
<li>Storing an opaque <code>UniqueId</code> instead of the string <code>key</code> limits the proliferation of personal data across different databases.</li>
<li>We automatically know the date that we first saw an entity with no additional storage. We use this signal often in the anti-spam, anti-fraud and security domains that SQRL is primarily used in.</li>
<li>If the <code>UniqueId</code> is used as a database key, most databases will store entities in chronological order (i.e. B-trees and LSM-trees, the most popular type of DB indexes, store rows in key-sorted order). When doing spam, fraud, or security investigations, you usually want to query the oldest or newest entities of a given type, which won’t require a separate (slow) sort step since they’re already sorted.</li>
</ul>
<p>This has proven to be incredibly useful and we think it’s unique to SQRL.</p>
<h2 id="Can-run-synchronously"><a href="#Can-run-synchronously" class="headerlink" title="Can run synchronously"></a>Can run synchronously</h2><p>Many languages for event processing (i.e. <a target="_blank" rel="noopener" href="https://www.confluent.io/product/ksql/">KSQL</a>) expect to be run as part of an asynchronous stream processing pipeline. SQRL is designed to be run <em>either</em> in a pipeline <em>or</em> synchronously with events (with time limits as tight as 100ms). Production deployments often do both — an initial fast path synchronously (so that it can block a signup, notification, etc.) and a second slower path that can do in-depth analysis and clean up before much damage has been done.</p>
<h2 id="Shared-SQRL-libraries"><a href="#Shared-SQRL-libraries" class="headerlink" title="Shared SQRL libraries"></a>Shared SQRL libraries</h2><p>SQRL libraries can be shared between event types and customers, and specific features can be overridden (similar to how you can extend a class in an OOP language).</p>
<p>This let Smyte create a common set of libraries for identifying spam in text content, and then apply them to a new customer with just a few lines of code to “wire up” the new customer’s event schemas.</p>
</body></html>
        <div id="react-support-footer-root"></div>
      </div>
    </div>
  </div>
</div>

    


    

    <!-- js vendors -->
    <script src="//code.jquery.com/jquery-3.2.1.min.js" crossorigin="anonymous"></script>
    <script src="//cdnjs.cloudflare.com/ajax/libs/lunr.js/2.1.0/lunr.min.js"></script>

    <!-- js source  -->
    <script src="/sqrl/script/doc.js"></script>

    

  </body>
</html>
